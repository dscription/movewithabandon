{% extends 'base.html' %}
{% load static %}
{% block content %}

<h1>Hello!</h1>
<script >
// p5.disableFriendlyErrors = true;

// PoseNet and ML5 Variables
let poseNet;
let poses = [];
let skeletons = [];
// Right Wrist
let rightWristX;
let rightWristY;
// Left Wrist
let leftWristX;
let leftWristY;


// p5 variables
let frameRate = 30
let canvas;
let video;
let pg;

// WebMWriter
var videoWriter = new WebMWriter({
    quality: 0.8,    // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (VP8L lossless) is not supported
    fileWriter: null, // FileWriter in order to stream to a file instead of buffering to memory (optional)
    fd: null,         // Node.js file handle to write to instead of buffering to memory (optional)
    // You must supply one of:
    frameDuration: null, // Duration of frames in milliseconds
    frameRate: 30,     // Number of frames per second
    transparent: false,      // True if an alpha channel should be included in the video
    alphaQuality: undefined, // Allows you to set the quality level of the alpha channel separately.
                             // If not specified this defaults to the same value as `quality`.
});

function setup() {

  // Canvas
  let p5canvas = createCanvas(640, 480);
  canvas = p5canvas.canvas;
  angleMode(DEGREES);

  // Video
  video = createCapture(VIDEO);
  video.size(width, height);

  // Create Graphics
  pg = createGraphics(width, height);
  // pg.clear();

  // PoseNet Instance with single user detection
  poseNet = ml5.poseNet(video, "single", modelReady);
  poseNet.on("pose", function (results) {
    poses = results;
  });

  // Hide the video element, and just show the canvas
  video.hide();
  
}

function draw() {
  // Start Counting Seconds Elapsed
  let secondsElapsed = frameCount/frameRate;

  // ML5 Experiments Go Here
  image(video, 0, 0, width, height);
  image(pg, 0, 0, width, height);

  drawKeypoints();
  // drawSkeleton();

  videoWriter.addFrame(canvas)
  // Write out video and make Fetch request ::: START
  if (secondsElapsed == 5) {
    let videoC = videoWriter.complete();

    var cl = new cloudinary.Cloudinary({cloud_name: "dct4e2zsl", secure: true});
    var cloudName = 'dct4e2zsl'
    var endp = `https://api.cloudinary.com/v1_1/${cloudName}/upload`
    var formData = new FormData();
    videoC.then(v => {
      formData.append("file", v)
      formData.append("upload_preset", "sickfits")
      fetch(
        endp, 
        {
        method: "POST",
        body: formData
      })
      .then((response) => {
        return response.json()
      })
      .then(
        (data) => {
          var djangoFormData = new FormData();
          djangoFormData.url = data.url
          fetch(
          'http://localhost:8000/videos/create/',
            {
            method: 'POST',
            mode: 'same-origin',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
              'X-CSRFToken': "{{csrf_token}}"
            },
            body: JSON.stringify({'url': data.url})
          }
        )
        .then(response => 
        {
          console.log('hit')
          window.location.replace('http://localhost:8000/private_index/')
        }
        )
        }
      )
    })
  }
  // Write out video and make Fetch request ::: END
}

// A function to draw ellipses over the detected keypoints
function drawKeypoints() {
  // Loop through all the poses detected
  for (let i = 0; i < min(poses.length, 1); i += 16) {
    // For each pose detected, loop through all the keypoints
    for (let j = 0; j < poses[i].pose.keypoints.length; j++) {
      // A keypoint is an object describing a body part (like rightArm or leftShoulder)
      let keypoint = poses[i].pose.keypoints[j];
      // Only draw an ellipse is the pose probability is bigger than 0.2
      if (keypoint.score > 0.2) {
        if (j == 10) {
          let brushes = [];
          rightWristX = keypoint.position.x;
          rightWristY = keypoint.position.y;

          brushes.push(
            new Brush(pg, rightWristX, rightWristY, random(255), 100, 180)
          );

          for (var k = 0; k < brushes.length; k++) {
            brushes[k].update();
            brushes[k].show();
          }
        }

        if (j == 9) {
          let leftBrushes = [];
          leftWristX = keypoint.position.x;
          leftWristY = keypoint.position.y;

          leftBrushes.push(
            new Brush(pg, leftWristX, leftWristY, 20, random(255), 100)
          );

          for (var l = 0; l < leftBrushes.length; l++) {
            leftBrushes[l].update();
            leftBrushes[l].show();
          }
        }
      }
    }
  }
}

// A function to draw the skeletons
function drawSkeleton() {
  // Loop through all the skeletons detected
  for (let i = 0; i < poses.length; i++) {
    // For every skeleton, loop through all body connections
    for (let j = 0; j < poses[i].skeleton.length; j++) {
      let partA = poses[i].skeleton[j][0];
      let partB = poses[i].skeleton[j][1];
      stroke(255, 0, 0);
      line(
        partA.position.x,
        partA.position.y,
        partB.position.x,
        partB.position.y
      );
    }
  }
}

// The callback that gets called every time there's an update from the model
function gotPoses(results) {
  poses = results;
}

// function keyPressed() {
//   pg.clear();
// }

function modelReady() {
  select("#status").html("model Loaded");
}

// create brush object
function Brush(pg, x, y, redCol, greenCol, blueCol) {
  this.x = x;
  this.y = y;
  this.pg = pg;
  this.redCol = redCol;
  this.greenCol = greenCol;
  this.blueCol = blueCol;

  this.history = [];

  this.update = function () {
    // return to this part to try making a fun random moving ellipse.
    this.x += random(-5, 5);
    this.y += random(-5, 5);

    for (var i = 0; i < this.history.length; i++) {
      this.history[i].x += random(-2, 2);
      this.history[i].y += random(-2, 2);
    }

    var v = createVector(this.x, this.y);
    this.history.push(v);
    if (this.history.length > 20) {
      this.history.splice(0, 1);
    }
  };

  this.show = function () {
    this.pg.stroke(0);
    this.pg.fill(this.redCol, this.greenCol, this.blueCol);
    this.pg.ellipse(this.x, this.y, 12, 12);
  };
}

function mouseClicked() {
  pg.clear();
}

</script>

{% endblock %}